Day1: Arrays
Two Sum
Problem Statement:
Given a list of item prices, find indices of two items whose combined price equals a customer's gift biked value.
Sample Input:
nums = [2, 7, 11, 15], target = 9
Expected Output:
[0, 1]
Explanation: The items at index 0 and 1 add up to 9 (2 + 7 = 9).

{
        "expertId":123,
        "ctc":4,
        "role":"developer"
    },
    {
        "expertId":456,
        "ctc":9,
        "role":"project manager"
    },
    {
        "expertId":765,
        "ctc":6,
        "role":"devops engineer"
    },
    {
        "expertId":912,
        "ctc":5,
        "role":"system design engineer"
    },
    {
        "expertId":123,
        "ctc":3,
        "role":"sdet"
    }

test cases:

target: 10
[developer, devops engineer]

target: 11
[devops engineer, system design engineer]



Maximum Subarray (Kadane’s Algorithm)
Problem Statement:
Find the contiguous period of maximum net income from daily financial logs.
Sample Input:
nums = [-2, 1, -3, 4, -1, 2, 1, -5, 4]
Expected Output:
6
Explanation: Subarray [4, -1, 2, 1] yields the highest sum.




Move Zeroes
Problem Statement:
Rearrange a delivery queue where zeros indicate unavailable trucks; push them to the end without disrupting the rest.

	Sample Input:
	nums = [0, 1, 0, 3, 12]
	Expected Output:
	[1, 3, 12, 0, 0]

	Input:
	20,0,19,5,0,3,10,0,2
	Output:
	20,19,5,3,10,2,0,0,0

	Input:
	3,0,0,1,0,5,0,6,0
	Output:
	3,1,5,6,0,0,0,0,0


Best Time to Buy and Sell Stock
Problem Statement:
Identify the best day to buy and the best day to sell for highest profit from historical stock prices.
Sample Input:
	prices = [7, 1, 5, 3, 6, 4]
	Buy at 1 and sell at 6.

	45, 12, 3, 10, 50
	Best time to buy 3 best time to sell 50

	-10, -5, -2, -1, 1
	Best time to buy -10 best time to sell 1

	90, 40, 20, 10, 4
	Best time to buy 10 best time to sell 4




	Find Pivot Index
	Problem Statement:
	Determine the index at which the workload to its left equals the workload to its right.
	Sample Input:
	nums = [1, 7, 3, 6, 5, 6]
	Expected Output:
	3
	Explanation: 1 + 7 + 3 = 11, 5 + 6 = 11.
	Input:
	-7, 1, 5, 2, -4, 3, 0
	Output:
	3
	Input:
	0,-3,5,-4,-2,3,1,0
	Output:
	0




		Insert Interval
		Problem Statement:
		Insert a new booking and merge overlapping intervals in an existing schedule.

		Input: intervals = [[1,3],[6,9]], newInterval = [2,5]
		Output: [[1,5],[6,9]]

		Input: intervals = [[1,2],[3,5],[6,7],[8,10],[12,16]], newInterval = [4,8]
		Output: [[1,2],[3,10],[12,16]]
		Explanation: Because the new interval [4,8] overlaps with [3,5],[6,7],[8,10].







	Sort Colors (Dutch National Flag)
	Problem Statement:
		Assume that your are part of support team in IRCTC app where customers would raise issue and it will be considered priority ticket such as 0, 1 and 2. now today tickets are in the bucket and you need to arrange it by priority
		Example:
		Input:
		2,0,0,1,0,2,0,1
		Output:
		0,0,0,0,1,1,2,2
		Sample Input:
		nums = [2, 0, 2, 1, 1, 0]
		Expected Output:
		[0, 0, 1, 1, 2, 2]




Day 2: Arrays, String
		1. In the super market end of each day finding the raised bills to customer with invoice number, now find the 		missing invoice of the day.
		Example:
		Input:
		8,10,3,1,4,2,5
		Output:
		6
		Input:
		45,91,90,92,46
		Output:
		47
		Input:
		0,1,2,4,5,6,7
		Output:
		3

2. Find and apply charges of 20 each extra debit more than 3 in last 10 transaction of your account which has credit and debit combination
		Example:
		Input:
		900,1200,5600,120,450,670,100,10000,400,120
		Output:
		900,1200,5600,120,450,670,100,10000,400,96



3. Given an array nums of positive integers of size N. Find all distinct digits present in nums.
		Example 1:
		Input: nums = [131, 11, 48]
		Output: 1 3 4 8
		Explanation: 1, 3, 4, and 8 are only distinct
		digits that can be extracted from the numbers
		of the array.
		Example 2:
		Input: nums = [111, 222, 333, 4444, 666]
		Output: 1 2 3 4 6
		Explanation: 1, 2, 3, 4, and 6 are only distinct
		digits that can be extracted from the numbers
		of the array.


4. Twisted prime
Note: A number is called Twisted Prime if it is a prime and its reverse is also a prime.
Example 1:
Input: N = 97
Output: 1
Explanation: 97 is a prime number. Its 
reverse 79 is also a prime number. Thus 
97 is a  twisted Prime and so, the answer is 1.
Example 2:
Input: N = 43
Output: 0
Explanation: 43 is a prime number but its 
reverse 34 is not a prime.So, 43 is not a 
twisted prime and thus, answer is 0.

Find the least prime number within the boundary that can be added with first array element that makes them divisible by second array elements at respective index
		Input:
		int[] arr1 = {3, 5, 7};
		int[] arr2 = {10, 15, 20};
		Output:
		7 -1 13 
		Input:
		int[] arr1 = {4, 6, 8};
		int[] arr2 = {5, 10, 15};
		Output:
		-1 -1 -1




		Strings:
		Given two strings A and B, find if A is a subsequence of B.
		Example 1:
		Input:
		A = TCS
		B = Tata Service
		Output: 0
		Explanation: A is not a subsequence of B
		as 'C' appears after 'S'
		Example 2:
		Input:
		A = infy
		B = infosys
		Output: 1
		Explanation: A is a subsequence of B.
		Example 3:
		Input:
		A = cts
		B = cognizant technology
		Output: 0
		Explanation: A is not a subsequence of B.



Minimum Moves to Convert String
You are given a string s consisting of n characters which are either 'X' or 'O'.
A move is defined as selecting three consecutive characters of s and converting them to 'O'. Note that if a move is applied to the character 'O', it will stay the same.
Return the minimum number of moves required so that all the characters of s are converted to 'O'.
		Example 1:
		Input: s = "XXX"
		Output: 1	
		Explanation: XXX -> OOO
		We select all the 3 characters and convert them in one move.
		Example 2:
		Input: s = "XXOX"
		Output: 2
		Explanation: XXOX -> OOOX -> OOOO
We select the first 3 characters in the first move, and convert them to 'O'.
Then we select the last 3 characters and convert them so that the final string contains all 'O's.
		Example 3:
		Input: s = "OOOO"
		Output: 0
Explanation: There are no 'X's in s to convert.



Consider that you are building console interface of customer's loan application where customer used to provide name, pan, aadhaar, email then they will set the password for their account. your role is to validate those information's using regex.
Example:
Input:
Name: "Raz",
Password: "razak$123",
Aadhaar: "765456787912",
PAN: "ABCDE1234F",
Email: "example@mail.com"

Output:
Account created

Example:
Input:
Name: "Ra",
Password: "razak$123",
Aadhaar: "7654567",
PAN: "ABCDE1234F",
Email: "example@mail.com"

Output:
Invalid name,invalid aadhaar

Example:
Input:
Name: "Raz",
Password: "razak123",
Aadhaar: "765456787912",
PAN: "ABCDE1234F",
Email: "example@mail.c"

Output:
Invalid password, invalid email




		Validating IPV4
		Input: s = "222.111.111.111"
		Output: true
		Explanation: Here, the IPv4 address is as per the criteria mentioned and also 		all four decimal numbers lies in the mentioned range.
		Input: s = "5555..555"
		Output: false
		Explanation: "5555..555" is not a valid. IPv4 address, as the middle two 			portions are missing.
		Input: s = "0.0.0.0255"
		Output: false




		Group Anagrams
		Problem Statement:
		Cluster search queries or user aliases that are scrambled versions of each other — useful in NLP or 		search optimization.
		Sample Input:
		strs = ["eat","tea","tan","ate","nat","bat"]
		Expected Output:
		[["eat","tea","ate"], ["tan","nat"], ["bat"]]



Day 3: Recursions
1. Assume that grocery shop generating bills with different amount, now the shopkeeper wants to cumulate the bills. so help him to find total revenue by using recursion
	Example:
	Input:
	[900,20,450,210,60]
	Output:
	1640




2. Find Max in array using recursion
		Example:
		Input: 0, 4, 5, 3, 7, 2, 1
		Output: 7

3. Using recursion, you are working on a vending machine software that dispenses change. Given an unlimited supply of currencies of different denominations (e.g., 100, 200, 500 etc.), you need to write a program to determine the minimum number of currencies required to make a given amount x. The program should accept the amount x and the list of denominations as input and output the minimum number of coins needed.
		Input: coins = [100, 200, 500]  , amount = 1100
		Output: 3
		Input: coins = [100, 200, 500]  , amount = 8700
		Output: 18

4. Using recursion find prefix and postfix sum
Input:
23,12,98,45,18,45,12,98
Output:
Prefix Sum: [23, 35, 133, 178, 196, 241, 253, 351]
Postfix Sum: [351, 328, 316, 218, 173, 155, 110, 98]


5. merge sort


6. using recursion find inversion count
Using recursion find the inversion of count
You are working for an e-commerce company that deals with a large volume of customer orders. The company wants to optimize its warehouse operations by analyzing the efficiency of order processing.
The goal is to count the number of inversion pairs in the order processing times to identify potential inefficiencies. An inversion pair in this context is defined as a situation where a later order (in terms of processing sequence) took less time to process than an earlier order. By identifying these inversions, you can pinpoint areas where the warehouse team may need to improve their workflow or processes.
Input
An array P[] of n integers representing the processing times of orders, in the order they were processed.
Output
The count of inversion pairs in the array.

		Example
		Input:
		P[] = [30, 45, 25, 60, 20]
		Output:
		The inversion count is 6
		Explanation: There are 5 inversion pairs in the array:
		(45, 25) where 45 > 25 and 
		(45, 20) where 45 > 20 and 
		(30, 25) where 30 > 25 and 
		(30, 20) where 30 > 20 and 
		(60, 20) where 60 > 20 and 
		(25, 20) where 25 > 20


Day 4:
		1. Find Factorial using recursion
		Example:
		Input: 5 
		Output: 120


		2. Find and print Fibonacci series using recursion
		Example:
		Input: 6
		Output: 0 1 1 2 3 5
		Input: 3
		Output: 0 1 1
		Input: 10
		Output: 0 1 1 2 3 5 8 13 21 34








3. This is one of the most popular coding problems which can be solved using the Dynamic Programming technique. In this problem we gonna find via recursion i.e divide and conquer, you are climbing a staircase. It takes n steps to reach the top. Each time you can either climb 1 or 2 steps. The question is, in how many distinct ways can you climb to the top?
Note: Given n will be a positive integer.
		Example 1:
		Input: 2
		Output: 2
		Explanation: There are two ways to climb to the top.
		1. 1 step + 1 step
		2. 2 steps
		Example 2:
		Input: 3
		Output: 3
		Explanation: There are three ways to climb to the top.
		1. 1 step + 1 step + 1 step
		2. 1 step + 2 steps
		3. 2 steps + 1 step.
		Example 3:
		Input: 5
		Output: 8

		

		


		4. Letter Combinations of a Phone Number
		Problem Statement:
		Simulate predictive text on keypads — generate all possible word combinations based 		on digit inputs, just like T9 on old phones.
		Sample Input:
		digits = "23"
		Expected Output:
		["ad", "ae", "af", "bd", "be", "bf", "cd", "ce", "cf"]



5. Find the ranking of your skill set in google trends ranking of 10 demanded trends such as [Java developer, cloud architect, data analyst, devops engineer ,full stack developer, network associate] using binary search
		Example:
		Input: data analyst
		Output: 3
		Input: Devops engineer
		Output: -1
		Input: full stack developer
		Output: 5


6. Real-Time Scenario: Smart Home Security Optimization
    
    Problem: A smart home security system needs to determine the maximum 
    value of items that can be monitored without triggering adjacent sensors 
    (which would cause interference). Houses are arranged in a line, and 
    adjacent houses cannot be monitored simultaneously.
    
    Real-world application: IoT security systems, resource optimization

		Example: 
		Input: [100, 200, 300, 400, 500], 
		Output: 900
		Input: [500, 100, 300, 400, 200], 
		Output: 1000
		Input:[500, 100, 300, 400]
		Output: 900
		Input: [500, 400, 300, 200]
		Output: 800

Day 5:
Generate Parentheses
Problem Statement:
Design a code formatter to wrap operations in valid parentheses — useful in compiler design and syntax generation.
Sample Input:
n = 3
Expected Output:
["((()))","(()())","(())()","()(())","()()()"]



Quick Select:
Consider you are going to inquire about top kth package from placement history of past year companies offered. NOTE: using quick select
Example:
Input:[14, 23, 7, 15, 20]
k = 2
Output:20
k = 1
Output: 23
k = 5
Output: 7







Climbing Stairs via DP
Input: 5
Output: 8








	Factorial via DP:
	Input: 5
	Output: 120
	Input: 7
	Output: 5040










		Coin change via DP
		Input: coins = [100, 500, 200]  , amount = 1100
		Output: 3
		Input: coins = [100, 200, 500]  , amount = 8700
		Output: 18
		Input: [500,300], amount=1100
		Output: 3







Jump Game:
You’re given an array nums of non-negative integers where each element nums[i] is the maximum jump length from index i. Determine whether it’s possible to reach the last index starting from index 0.
Input Format:
- nums: List of integers (1 ≤ len(nums) ≤ 10⁴; 0 ≤ nums[i] ≤ 1000)
Output Format:
- Boolean value (True or False).
Sample Input:
nums = [2, 3, 1, 1, 4]
Sample Output:
True
Explanation:
Start at 0 → jump 2 → index 2 → jump 1 → index 3 → jump 1 → index 4.




Max SubSum Kaden's with DP:
You are given an integer array nums. Find the contiguous subarray (at least one element) with the maximum possible sum.
Input Format:
- nums: List of integers of length n (1 ≤ n ≤ 10⁵; -10⁴ ≤ nums[i] ≤ 10⁴)
Output Format:
- An integer, the maximum subarray sum.
Sample Input:
nums = [-2, 1, -3, 4, -1, 2, 1, -5, 4]
Sample Output:
6
Explanation:
Maximum sum is from subarray [4, -1, 2, 1].


Day 6:(Half Day)
Decode ways:
Given a string s containing digits only, return the total number of ways to decode it using the mapping: 'A' = 1 to 'Z' = 26. '0' cannot be decoded on its own.
Input Format:
- s: A string of digits (1 ≤ len(s) ≤ 100)
Output Format:
- An integer denoting the number of decoding ways.
		Sample Input:
		s = "226"
		Sample Output:
		3
		Explanation:
		Valid decodings: "BZ", "VF", "BBF".






Grid Path Count MxN
Imagine you're designing an autonomous robot for warehouse navigation. The warehouse floor is laid out in an m x n grid. The robot can only move right or down, starting from the top-left cell to the bottom-right. You need to calculate how many unique paths the robot can take to reach the destination.
		Example
		Input: 3 3
		Output: 6
		Input: 2 2
		Output: 2
		Input: 1 5
		Output: 1
		Input: 4 1
		Output: 1
		Input: 4 3
		Output: 10



Day 7:
Minimum Path Sum:
Let’s say you’re optimizing cost-efficient delivery routes across a grid-like city. Each cell in the grid contains a cost to enter that area. Starting from the top-left, the goal is to reach the bottom-right with the minimum total cost, only moving right or down.
		Example
		Input: [[1,3,1],[1,5,1],[4,2,1]]
		Output: 7
		Input: [[1,2],[1,1]]
		Output: 3
		Input: [[5]]
		Output: 5
		Input: [[1,2,3],[4,5,6]]
		Output: 12
		Input: [[1,1,1],[1,1,1],[1,1,1]]
		Output: 5


Minimum Distance to calculate transfer one word to another 
Imagine you are a software engineer working on a document editing application. The application allows users to edit and correct typos in their documents. One of the features you are developing is a tool to calculate the minimum number of operations required to transform one word into another. This feature is crucial for suggesting the most efficient edits and corrections to the users.
Task: Given two words, implement a function that calculates the minimum number of operations required to convert the first word into the second word. The allowed operations are:
Insert a character
Delete a character
Replace a character

Input:
Two strings word1 and word2 representing the original word and the target word, respectively.
Output:
An integer representing the minimum number of operations required to convert word1 into word2.

		Example:
		Input: word1 = "horse", word2 = "rose"
		Output: 2
		Explanation:
		To transform "horse" into "rose", the following 2 operations are required:
		  1. Replace 'h' with 'r' -> "rorse"
		  2. Delete 'r' -> "rose"



Bioinformatics - DNA Sequence Analysis
    Problem: Find the Longest Common Subsequence (LCS) between two DNA sequences.
    This helps in identifying genetic similarities, evolutionary relationships,
    and mutations in genetic research.
    Real-world application: Genetics, medical research, evolutionary biology
		Example:
		Input: text1 = abcde, text2 = ace
		Ouput: 3
		Input: text1 = abc, text2 = def
		Ouput: 0
		Input: text1 = aggtab, text2 = gxtxayb
		Ouput: 4
		Input: text1 = aaaa, text2 = aa
		Ouput: 2
		Input: text1 = abcdef, text2 = acf
		Ouput: 3



Corporate Resource Allocation
    Problem: A company has a limited budget and needs to select projects 
    that maximize profit. Each project has a cost and expected profit.
    This is a classic 0/1 Knapsack problem applied to business scenarios.
    Real-world application: Project management, investment decisions, resource allocation

		Example:
		Input 1        
		weights: [1,2,3]   values: [10,15,40]  capacity: 5
		Output1: 55
		Input 2
	        weights: [1,3,4,5]  values: [10,40,50,70]  capacity: 8
		Output: 110
		Input 3
	        weights: [1,2,3,2]  values: [10,20,30,40]  capacity: 5
		Output: 70



Cryptocurrency Trading Strategy
    Problem: Find all palindromic subsequences in price patterns to identify 
    potential trading opportunities. Palindromic patterns often indicate 
    market reversals or consolidation phases.
    Real-world application: Algorithmic trading, pattern recognition, financial analysis
		Example:
		Input: HLHLHHL
		Ouput: 5
		Input: HHLLHH
		Ouput: 6
		Input: HHHLL
		Ouput: 3

Day 8:
1. Daily Temperatures
Given an array of integers temperatures represents the daily temperatures, return an array answer such that answer[i] is the number of days you have to wait after the ith day to get a warmer temperature. If there is no future day for which this is possible, keep answer[i] == 0 instead.
		Example 1:
		Input: temperatures = [73,74,75,71,69,72,76,73]
		Output: [1,1,4,2,1,1,0,0]
		Example 2:
		Input: temperatures = [30,40,50,60]
		Output: [1,1,1,0]
		Example 3:
		Input: temperatures = [30,60,90]
		Output: [1,1,0]


2. Bike Fleet
There are n bikes at given miles away from the starting mile 0, traveling to reach the mile target.
You are given two integer array position and speed, both of length n, where position[i] is the starting mile of the ith bike and speed[i] is the speed of the ith bike in miles per hour.
A bike cannot pass another bike, but it can catch up and then travel next to it at the speed of the slower bike.
A bike fleet is a bike or bikes driving next to each other. The speed of the bike fleet is the minimum speed of any bike in the fleet.
If a bike catches up to a bike fleet at the mile target, it will still be considered as part of the bike fleet.
Return the number of bike fleets that will arrive at the destination.

A bike fleet is a group of bikes that travel together (a slower bike in front causes a faster bike behind to merge into a fleet).

Example 1:
Input: target = 12, position = [10,8,0,5,3], speed = [2,4,1,1,3]
Output: 3
Explanation:
The bikes starting at 10 (speed 2) and 8 (speed 4) become a fleet, meeting each other at 12. The fleet forms at target.
The bike starting at 0 (speed 1) does not catch up to any other bike, so it is a fleet by itself.
The bikes starting at 5 (speed 1) and 3 (speed 3) become a fleet, meeting each other at 6. The fleet moves at speed 1 until it reaches target.

Example 2:
Input: target = 10, position = [3], speed = [3]
Output: 1
Explanation:
There is only one bike, hence there is only one fleet.

Example 3:
Input: target = 100, position = [0,2,4], speed = [4,2,1]
Output: 1
Explanation:
The bikes starting at 0 (speed 4) and 2 (speed 2) become a fleet, meeting each other at 4. The bike starting at 4 (speed 1) travels to 5.
Then, the fleet at 4 (speed 2) and the bike at position 5 (speed 1) become one fleet, meeting each other at 6. The fleet moves at speed 1 until it reaches target.


3. Largest Rectangle in Histogram, Given an array of integers heights representing the histogram's bar height where the width of each bar is 1, return the area of the largest rectangle in the histogram.

Example 1:
Input: heights = [2,1,5,6,2,3]
Output: 10
Explanation: The above is a histogram where width of each bar is 1.
The largest rectangle is shown in the red area, which has an area = 10 units.

Example 2:
Input: heights = [2,4]
Output: 4


4. Valid Parentheses
Given a string s containing just the characters '(', ')', '{', '}', '[' and ']', determine if the input string is valid.

An input string is valid if:
Open brackets must be closed by the same type of brackets.
Open brackets must be closed in the correct order.
Every close bracket has a corresponding open bracket of the same type.

Constraints:
s consists of parentheses only '()[]{}'.

Example 1:
Input: s = "()"
Output: true

Example 2:
Input: s = "()[]{}"
Output: true

Example 3:
Input: s = "(]"
Output: false

Example 4:
Input: s = "([])"
Output: true

Example 5:
Input: s = "([)]"
Output: false

5. Evaluate Reverse Polish Notation
You are given an array of strings tokens that represents an arithmetic expression in a Reverse Polish Notation.
Evaluate the expression. Return an integer that represents the value of the expression.
Note that:
The valid operators are '+', '-', '*', and '/'.
Each operand may be an integer or another expression.
The division between two integers always truncates toward zero.
There will not be any division by zero.
The input represents a valid arithmetic expression in a reverse polish notation.
The answer and all the intermediate calculations can be represented in a 32-bit integer.
 
Example 1:
Input: tokens = ["2","1","+","3","*"]
Output: 9
Explanation: ((2 + 1) * 3) = 9

Example 2:
Input: tokens = ["4","13","5","/","+"]
Output: 6
Explanation: (4 + (13 / 5)) = 6

Example 3:
Input: tokens = ["10","6","9","3","+","-11","*","/","*","17","+","5","+"]
Output: 22
Explanation: ((10 * (6 / ((9 + 3) * -11))) + 17) + 5
= ((10 * (6 / (12 * -11))) + 17) + 5
= ((10 * (6 / -132)) + 17) + 5
= ((10 * 0) + 17) + 5
= (0 + 17) + 5
= 17 + 5
= 22

Day 9:
1. First Non-Repeating Character in a Stream
For a given stream of lowercase letters, output the first non-repeating character after each input character.
In many real-time systems, it is important to track the first non-repeating character from a stream of characters.
You are given a string s, which represents a stream of lowercase English letters.
Your task is to output a new string where each character at position i represents the first non-repeating character in the stream up to the ith character. If there is no such character, append #.

Input Format:
A single line containing a string s consisting of lowercase English letters.

s contains only lowercase English letters.

Output Format:
A single string of length equal to s, where each character represents the first non-repeating character in the stream up to that point or # if none exists.

Tags:
queues, hashmaps, strings, implementation, real-time stream

Test Case 1
Input: aabc
Expected Output: a#bb
Test Case 2
Input: abcabc
Expected Output:aaabc#
Test Case 3
Input: aabbcc
Expected Output: a#b#c#
Test Case 4
Input: xxyyz
Expected Output: x#y#z
Test Case 5
Input: abacabad
Output: aabbbccc





2. Number of Students Unable to Eat Lunch
The school cafeteria offers circular and square sandwiches at lunch break, referred to by numbers 0 and 1 respectively. All students stand in a queue. Each student either prefers square or circular sandwiches.
The number of sandwiches in the cafeteria is equal to the number of students. The sandwiches are placed in a stack. At each step:
If the student at the front of the queue prefers the sandwich on the top of the stack, they will take it and leave the queue.
Otherwise, they will leave it and go to the queue's end.
This continues until none of the queue students want to take the top sandwich and are thus unable to eat.
You are given two integer arrays students and sandwiches where sandwiches[i] is the type of the i​​​​​​th sandwich in the stack (i = 0 is the top of the stack) and students[j] is the preference of the j​​​​​​th student in the initial queue (j = 0 is the front of the queue). Return the number of students that are unable to eat.

Example 1:
Input: students = [1,1,0,0], sandwiches = [0,1,0,1]
Output: 0 
Explanation:
- Front student leaves the top sandwich and returns to the end of the line making students = [1,0,0,1].
- Front student leaves the top sandwich and returns to the end of the line making students = [0,0,1,1].
- Front student takes the top sandwich and leaves the line making students = [0,1,1] and sandwiches = [1,0,1].
- Front student leaves the top sandwich and returns to the end of the line making students = [1,1,0].
- Front student takes the top sandwich and leaves the line making students = [1,0] and sandwiches = [0,1].
- Front student leaves the top sandwich and returns to the end of the line making students = [0,1].
- Front student takes the top sandwich and leaves the line making students = [1] and sandwiches = [1].
- Front student takes the top sandwich and leaves the line making students = [] and sandwiches = [].
Hence all students are able to eat.

Example 2:
Input: students = [1,1,1,0,0,1], sandwiches = [1,0,0,0,1,1]
Output: 3

3. Minimum Sum of Values by Dividing Array
You are given two arrays nums and andValues of length n and m respectively.
The value of an array is equal to the last element of that array.
You have to divide nums into m disjoint contiguous subarrays such that for the ith subarray [li, ri], the bitwise AND of the subarray elements is equal to andValues[i], in other words, nums[li] & nums[li + 1] & ... & nums[ri] == andValues[i] for all 1 <= i <= m, where & represents the bitwise AND operator.
Return the minimum possible sum of the values of the m subarrays nums is divided into. If it is not possible to divide nums into m subarrays satisfying these conditions, return -1.
Example 1:
Input: nums = [1,4,3,3,2], andValues = [0,3,3,2]
Output: 12
Explanation:
The only possible way to divide nums is:
[1,4] as 1 & 4 == 0.
[3] as the bitwise AND of a single element subarray is that element itself.
[3] as the bitwise AND of a single element subarray is that element itself.
[2] as the bitwise AND of a single element subarray is that element itself.
The sum of the values for these subarrays is 4 + 3 + 3 + 2 = 12.

Example 2:
Input: nums = [2,3,5,7,7,7,5], andValues = [0,7,5]
Output: 17
Explanation:
There are three ways to divide nums:
[[2,3,5],[7,7,7],[5]] with the sum of the values 5 + 7 + 5 == 17.
[[2,3,5,7],[7,7],[5]] with the sum of the values 7 + 7 + 5 == 19.
[[2,3,5,7,7],[7],[5]] with the sum of the values 7 + 7 + 5 == 19.
The minimum possible sum of the values is 17.

Example 3:
Input: nums = [1,2,3,4], andValues = [2]
Output: -1

Explanation:
The bitwise AND of the entire array nums is 0. As there is no possible way to divide nums into a single subarray to have the bitwise AND of elements 2, return -1

Constraints:
1 <= n == nums.length <= 104
1 <= m == andValues.length <= min(n, 10)
1 <= nums[i] < 105
0 <= andValues[j] < 105





4. There are a number of plants in a garden. Each of the plants has been treated with some amount of pesticide. After each day, if any plant has more pesticide than the plant on its left, being weaker than the left one, it dies.
You are given the initial values of the pesticide in each of the plants. Determine the number of days after which no plant dies, i.e. the time after which there is no plant with more pesticide content than the plant to its left.
pesticide levels
Use a -indexed array. On day , plants  and  die leaving . On day , plant  in  dies leaving . There is no plant with a higher concentration of pesticide than the one to its left, so plants stop dying after day .
Function Description
Complete the function poisonousPlants in the editor below.
poisonousPlants has the following parameter(s):
int p[n]: the pesticide levels in each plant

Returns
- int: the number of days until plants no longer die from pesticide

Input Format
The first line contains an integer , the size of the array .
The next line contains  space-separated integers .

Sample Input
		7
		6 5 8 4 7 10 9
		Sample Output
		2
		Explanation
Initially all plants are alive.
Plants = {(6,1), (5,2), (8,3), (4,4), (7,5), (10,6), (9,7)}
Plants[k] = (i,j) => jth plant has pesticide amount = i.
After the 1st day, 4 plants remain as plants 3, 5, and 6 die.
Plants = {(6,1), (5,2), (4,4), (9,7)}
After the 2nd day, 3 plants survive as plant 7 dies.
Plants = {(6,1), (5,2), (4,4)}
Plants stop dying after the 2nd day.




5. Delivering Boxes from Storage to Ports
You have the task of delivering some boxes from storage to their ports using only one ship. However, this ship has a limit on the number of boxes and the total weight that it can carry.
You are given an array boxes, where boxes[i] = [ports​​i​, weighti], and three integers portsCount, maxBoxes, and maxWeight.
ports​​i is the port where you need to deliver the ith box and weightsi is the weight of the ith box.
portsCount is the number of ports.
maxBoxes and maxWeight are the respective box and weight limits of the ship.
The boxes need to be delivered in the order they are given. The ship will follow these steps:
The ship will take some number of boxes from the boxes queue, not violating the maxBoxes and maxWeight constraints.
For each loaded box in order, the ship will make a trip to the port the box needs to be delivered to and deliver it. If the ship is already at the correct port, no trip is needed, and the box can immediately be delivered.
The ship then makes a return trip to storage to take more boxes from the queue.
The ship must end at storage after all the boxes have been delivered.
Return the minimum number of trips the ship needs to make to deliver all boxes to their respective ports.

Example 1:
Input: boxes = [[1,1],[2,1],[1,1]], portsCount = 2, maxBoxes = 3, maxWeight = 3
Output: 4
Explanation: The optimal strategy is as follows: 
- The ship takes all the boxes in the queue, goes to port 1, then port 2, then port 1 again, then returns to storage. 4 trips.
So the total number of trips is 4.
Note that the first and third boxes cannot be delivered together because the boxes need to be delivered in order (i.e. the second box needs to be delivered at port 2 before the third box).

Example 2:
Input: boxes = [[1,2],[3,3],[3,1],[3,1],[2,4]], portsCount = 3, maxBoxes = 3, maxWeight = 6
Output: 6
Explanation: The optimal strategy is as follows: 
- The ship takes the first box, goes to port 1, then returns to storage. 2 trips.
- The ship takes the second, third and fourth boxes, goes to port 3, then returns to storage. 2 trips.
- The ship takes the fifth box, goes to port 2, then returns to storage. 2 trips.
So the total number of trips is 2 + 2 + 2 = 6.

Example 3:
Input: boxes = [[1,4],[1,2],[2,1],[2,1],[3,2],[3,4]], portsCount = 3, maxBoxes = 6, maxWeight = 7
Output: 6
Explanation: The optimal strategy is as follows:
- The ship takes the first and second boxes, goes to port 1, then returns to storage. 2 trips.
- The ship takes the third and fourth boxes, goes to port 2, then returns to storage. 2 trips.
- The ship takes the fifth and sixth boxes, goes to port 3, then returns to storage. 2 trips.
So the total number of trips is 2 + 2 + 2 = 6.
 
Constraints:
1 <= boxes.length <= 105
1 <= portsCount, maxBoxes, maxWeight <= 105
1 <= ports​​i <= portsCount
1 <= weightsi <= maxWeight

6. Reveal Cards In Increasing Order
You are given an integer array deck. There is a deck of cards where every card has a unique integer. The integer on the ith card is deck[i].
You can order the deck in any order you want. Initially, all the cards start face down (unrevealed) in one deck.
You will do the following steps repeatedly until all cards are revealed:
Take the top card of the deck, reveal it, and take it out of the deck.
If there are still cards in the deck then put the next top card of the deck at the bottom of the deck.
If there are still unrevealed cards, go back to step 1. Otherwise, stop.
Return an ordering of the deck that would reveal the cards in increasing order.
Note that the first entry in the answer is considered to be the top of the deck.

Example 1:
Input: deck = [17,13,11,2,3,5,7]
Output: [2,13,3,11,5,17,7]
Explanation: 
We get the deck in the order [17,13,11,2,3,5,7] (this order does not matter), and reorder it.
After reordering, the deck starts as [2,13,3,11,5,17,7], where 2 is the top of the deck.
We reveal 2, and move 13 to the bottom.  The deck is now [3,11,5,17,7,13].
We reveal 3, and move 11 to the bottom.  The deck is now [5,17,7,13,11].
We reveal 5, and move 17 to the bottom.  The deck is now [7,13,11,17].
We reveal 7, and move 13 to the bottom.  The deck is now [11,17,13].
We reveal 11, and move 17 to the bottom.  The deck is now [13,17].
We reveal 13, and move 17 to the bottom.  The deck is now [17].
We reveal 17.
Since all the cards revealed are in increasing order, the answer is correct.

Example 2:
Input: deck = [1,1000]
Output: [1,1000]

Constraints:
1 <= deck.length <= 1000
1 <= deck[i] <= 106
All the values of deck are unique.



Day 10:
1. Dota2 Senate
In the world of Dota2, there are two parties: the Radiant and the Dire.
The Dota2 senate consists of senators coming from two parties. Now the Senate wants to decide on a change in the Dota2 game. The voting for this change is a round-based procedure. In each round, each 

senator can exercise one of the two rights:
Ban one senator's right: A senator can make another senator lose all his rights in this and all the following rounds.
Announce the victory: If this senator found the senators who still have rights to vote are all from the same party, he can announce the victory and decide on the change in the game.

Given a string senate representing each senator's party belonging. The character 'R' and 'D' represent the Radiant party and the Dire party. Then if there are n senators, the size of the given string will be n.
The round-based procedure starts from the first senator to the last senator in the given order. This procedure will last until the end of voting. All the senators who have lost their rights will be skipped during the procedure.
Suppose every senator is smart enough and will play the best strategy for his own party. 

Predict which party will finally announce the victory and change the Dota2 game. The output should be "Radiant" or "Dire".

Example 1:
Input: senate = "RD"
Output: "Radiant"
Explanation: 
The first senator comes from Radiant and he can just ban the next senator's right in round 1. 
And the second senator can't exercise any rights anymore since his right has been banned. 
And in round 2, the first senator can just announce the victory since he is the only guy in the senate who can vote.

Example 2:
Input: senate = "RDD"
Output: "Dire"
Explanation: 
The first senator comes from Radiant and he can just ban the next senator's right in round 1. 
And the second senator can't exercise any rights anymore since his right has been banned. 
And the third senator comes from Dire and he can ban the first senator's right in round 1. 
And in round 2, the third senator can just announce the victory since he is the only guy in the senate who can vote.

Constraints:
n == senate.length
1 <= n <= 104
senate[i] is either 'R' or 'D'.


2. Reverse Nodes in k-Group, Given the head of a linked list, reverse the nodes of the list k at a time, and return the modified list.

k is a positive integer and is less than or equal to the length of the linked list. If the number of nodes is not a multiple of k then left-out nodes, in the end, should remain as it is.
You may not alter the values in the list's nodes, only nodes themselves may be changed.

Example 1:
Input: head = [1,2,3,4,5], k = 2
Output: [2,1,4,3,5]

Example 2:
Input: head = [1,2,3,4,5], k = 3
Output: [3,2,1,4,5]


3. Minimum Window Substring
User Behavior Analysis on E-commerce Platform
An e-commerce platform tracks user activities like "search product," "add to cart," and "checkout." To optimize user journeys, analysts want to find the shortest sequence containing all these events.

Problem Statement:
Given a list of user activities, find the smallest window containing all key actions.

Example:
Input:
activities = ["browse", "search product", "add to cart", "checkout", "feedback"]  
required_actions = ["search product", "checkout"]
Output:
["search product", "add to cart", "checkout"]


4. Sliding Window Maximum
Heart Rate Monitoring in Healthcare:
A wearable health device monitors a user's heart rate during exercise. To provide health insights, the device must track the highest heart rate over every 1-minute interval.
Problem Statement: Given an array heartRates[] and an integer k, find the maximum heart rate for each sliding window of size k.
Input1:
heartRates = [72, 80, 75, 90, 85, 92, 88]
k = 3
Output1:
Maximum heart rates for each sliding window:
[80, 90, 90, 92, 92]

heartRates = [70, 85, 60, 95, 82, 74, 90]
k = 2
Maximum heart rates for each sliding window:
[85, 85, 95, 95, 82, 90]
Window [70, 85] → max = 85
Window [85, 60] → max = 85
Window [60, 95] → max = 95
Window [95, 82] → max = 95
Window [82, 74] → max = 82
Window [74, 90] → max = 90


5. Longest Repeating Character Replacement
You are given a string s and an integer k. You can choose any character of the string and change it to any other uppercase English character. You can perform this operation at most k times.
Return the length of the longest substring containing the same letter you can get after performing the above operations.

Example 1:
Input: s = "ABAB", k = 2
Output: 4
Explanation: Replace the two 'A's with two 'B's or vice versa.

Example 2:
Input: s = "AABABBA", k = 1
Output: 4
Explanation: Replace the one 'A' in the middle with 'B' and form "AABBBBA".
The substring "BBBB" has the longest repeating letters, which is 4.
There may exists other ways to achieve this answer too.

Constraints:
1 <= s.length <= 105
s consists of only uppercase English letters.
0 <= k <= s.length


Day 11:
1. Subarrays with K Different Integers
Given an integer array nums and an integer k, return the number of good subarrays of nums.
A good array is an array where the number of different integers in that array is exactly k.

For example, [1,2,3,1,2] has 3 different integers: 1, 2, and 3.
A subarray is a contiguous part of an array.

Example 1:
Input: nums = [1,2,1,2,3], k = 2
Output: 7
Explanation: Subarrays formed with exactly 2 different integers: [1,2], [2,1], [1,2], [2,3], [1,2,1], [2,1,2], [1,2,1,2]

Example 2:
Input: nums = [1,2,1,3,4], k = 3
Output: 3
Explanation: Subarrays formed with exactly 3 different integers: [1,2,1,3], [2,1,3], [1,3,4].
 
Constraints:
1 <= nums.length <= 2 * 104
1 <= nums[i], k <= nums.length



2. Merge k Sorted Lists
You are given an array of k linked-lists lists, each linked-list is sorted in ascending order.
Merge all the linked-lists into one sorted linked-list and return it.

Example 1:
Input: lists = [[1,4,5],[1,3,4],[2,6]]
Output: [1,1,2,3,4,4,5,6]
Explanation: The linked-lists are:
[  
	1->4->5,
	1->3->4,
	2->6
]
merging them into one sorted list:
1->1->2->3->4->4->5->6

Example 2:
Input: lists = []
Output: []

Example 3:
Input: lists = [[]]
Output: []



3. LRU Cache
Design a data structure that follows the constraints of a Least Recently Used (LRU) cache.
Implement the LRUCache class:
LRUCache(int capacity) Initialize the LRU cache with positive size capacity.
int get(int key) Return the value of the key if the key exists, otherwise return -1.
void put(int key, int value) Update the value of the key if the key exists. Otherwise, add the key-value pair to the cache. If the number of keys exceeds the capacity from this operation, evict the least recently used key.
The functions get and put must each run in O(1) average time complexity.

Example 1:
Input
["LRUCache", "put", "put", "get", "put", "get", "put", "get", "get", "get"]
[[2], [1, 10], [2, 100], [1], [3, 1000], [2], [4, 10000], [1], [3], [4]]
Output
[null, null, null, 1, null, -1, null, -1, 3, 4]
Explanation
LRUCache lRUCache = new LRUCache(2);
lRUCache.put(1, 10); // cache is {1=10}
lRUCache.put(2, 100); // cache is {1=10, 2=100}
lRUCache.get(1);    // return 10
lRUCache.put(3, 1000); // LRU key was 2, evicts key 2, cache is {1=10, 3=1000}
lRUCache.get(2);    // returns -1 (not found)
lRUCache.put(4, 10000); // LRU key was 1, evicts key 1, cache is {4=10000, 3=1000}
lRUCache.get(1);    // return -1 (not found)
lRUCache.get(3);    // return 1000
lRUCache.get(4);    // return 10000

Constraints:
1 <= capacity <= 3000
0 <= key <= 104
0 <= value <= 105
At most 2 * 105 calls will be made to get and put.



4. Reverse Nodes in k-Group
Given the head of a linked list, reverse the nodes of the list k at a time, and return the modified list.
k is a positive integer and is less than or equal to the length of the linked list. If the number of nodes is not a multiple of k then left-out nodes, in the end, should remain as it is.
You may not alter the values in the list's nodes, only nodes themselves may be changed.

Example 1:
Input: head = [1,2,3,4,5], k = 2
Output: [2,1,4,3,5]

Example 2:
Input: head = [1,2,3,4,5], k = 3
Output: [3,2,1,4,5]

Constraints:
The number of nodes in the list is n.
1 <= k <= n <= 5000
0 <= Node.val <= 1000
Follow-up: Can you solve the problem in O(1) extra memory space?



5. All O`one Data Structure
Design a data structure to store the strings' count with the ability to return the strings with minimum and maximum counts.

Implement the AllOne class:
AllOne() Initializes the object of the data structure.
inc(String key) Increments the count of the string key by 1. If key does not exist in the data structure, insert it with count 1.
dec(String key) Decrements the count of the string key by 1. If the count of key is 0 after the decrement, remove it from the data structure. It is guaranteed that key exists in the data structure before the decrement.
getMaxKey() Returns one of the keys with the maximal count. If no element exists, return an empty string "".
getMinKey() Returns one of the keys with the minimum count. If no element exists, return an empty string "".
Note that each function must run in O(1) average time complexity.

Example 1:
Input
["AllOne", "inc", "inc", "getMaxKey", "getMinKey", "inc", "getMaxKey", "getMinKey"]
[[], ["hello"], ["hello"], [], [], ["leet"], [], []]
Output
[null, null, null, "hello", "hello", null, "hello", "leet"]
Explanation
AllOne allOne = new AllOne();
allOne.inc("hello");
allOne.inc("hello");
allOne.getMaxKey(); // return "hello"
allOne.getMinKey(); // return "hello"
allOne.inc("leet");
allOne.getMaxKey(); // return "hello"
allOne.getMinKey(); // return "leet"
 
Constraints:
1 <= key.length <= 10
key consists of lowercase English letters.
It is guaranteed that for each call to dec, key is existing in the data structure.
At most 5 * 104 calls will be made to inc, dec, getMaxKey, and getMinKey.


Day 12: (Half Day)
Fixed Sliding window
1. reverse within given window
2. find sub sum within given window
Variable Sliding window
singly linked list creation and find followings

3. Merge k Sorted Lists

You are given an array of k linked-lists lists, each linked-list is sorted in ascending order.
Merge all the linked-lists into one sorted linked-list and return it.

Example 1:
Input: lists = [[1,4,5],[1,3,4],[2,6]]
Output: [1,1,2,3,4,4,5,6]
Explanation: The linked-lists are:
[  
	1->4->5,
	1->3->4,
	2->6
]
merging them into one sorted list:
1->1->2->3->4->4->5->6

Example 2:
Input: lists = []
Output: []

Example 3:
Input: lists = [[]]
Output: []




Day 13: Tree's
1. Binary Tree Maximum Path Sum
A path in a binary tree is a sequence of nodes where each pair of adjacent nodes in the sequence has an edge connecting them. A node can only appear in the sequence at most once. Note that the path does not need to pass through the root.
The path sum of a path is the sum of the node's values in the path.
Given the root of a binary tree, return the maximum path sum of any non-empty path.

Example 1:
Input: root = [1,2,3]
Output: 6
Explanation: The optimal path is 2 -> 1 -> 3 with a path sum of 2 + 1 + 3 = 6.

Example 2:
Input: root = [-10,9,20,null,null,15,7]
Output: 42
Explanation: The optimal path is 15 -> 20 -> 7 with a path sum of 15 + 20 + 7 = 42.

Constraints:
The number of nodes in the tree is in the range [1, 3 * 104].
-1000 <= Node.val <= 1000



2. Validate Binary Search Tree
Given the root of a binary tree, determine if it is a valid binary search tree (BST).
A valid BST is defined as follows:
The left subtree of a node contains only nodes with keys less than the node's key.
The right subtree of a node contains only nodes with keys greater than the node's key.
Both the left and right subtrees must also be binary search trees.
 
Example 1:
Input: root = [2,1,3]
Output: true

Example 2:
Input: root = [5,1,4,null,null,3,6]
Output: false
Explanation: The root node's value is 5 but its right child's value is 4.

Constraints:
The number of nodes in the tree is in the range [1, 104].
-231 <= Node.val <= 231 - 1



3. Balanced Binary Tree
Given a binary tree, determine if it is height-balanced.
Example 1:
Input: root = [3,9,20,null,null,15,7]
Output: true

Example 2:
Input: root = [1,2,2,3,3,null,null,4,4]
Output: false

Example 3:
Input: root = []
Output: true

Constraints:
The number of nodes in the tree is in the range [0, 5000].
-104 <= Node.val <= 104



Graph's
4. Cheapest Flights Within K Stops
There are n cities connected by some number of flights. You are given an array flights where flights[i] = [fromi, toi, pricei] indicates that there is a flight from city fromi to city toi with cost pricei.
You are also given three integers src, dst, and k, return the cheapest price from src to dst with at most k stops. If there is no such route, return -1.

Example 1:
Input: n = 4, flights = [[0,1,100],[1,2,100],[2,0,100],[1,3,600],[2,3,200]], 
src = 0, dst = 3, k = 1
Output: 700
Explanation:
The graph is shown above.
The optimal path with at most 1 stop from city 0 to 3 is marked in red and has cost 100 + 600 = 700.
Note that the path through cities [0,1,2,3] is cheaper but is invalid because it uses 2 stops.

Example 2:
Input: n = 3, flights = [[0,1,100],[1,2,100],[0,2,500]], src = 0, dst = 2, k = 1
Output: 200
Explanation:
The graph is shown above.
The optimal path with at most 1 stop from city 0 to 2 is marked in red and has cost 100 + 100 = 200.

Example 3:
Input: n = 3, flights = [[0,1,100],[1,2,100],[0,2,500]], src = 0, dst = 2, k = 0
Output: 500
Explanation:
The graph is shown above.
The optimal path with no stops from city 0 to 2 is marked in red and has cost 500.



5. Reconstruct Itinerary
You are given a list of airline tickets where tickets[i] = [fromi, toi] represent the departure and the arrival airports of one flight. Reconstruct the itinerary in order and return it.
All of the tickets belong to a man who departs from "JFK", thus, the itinerary must begin with "JFK". If there are multiple valid itineraries, you should return the itinerary that has the smallest lexical order when read as a single string.
For example, the itinerary ["JFK", "LGA"] has a smaller lexical order than ["JFK", "LGB"].
You may assume all tickets form at least one valid itinerary. You must use all the tickets once and only once.

Example 1:
Input: tickets = [["MUC","LHR"],["JFK","MUC"],["SFO","SJC"],["LHR","SFO"]]
Output: ["JFK","MUC","LHR","SFO","SJC"]

Example 2:
Input: tickets = [["JFK","SFO"],["JFK","ATL"],["SFO","ATL"],["ATL","JFK"],["ATL","SFO"]]
Output: ["JFK","ATL","JFK","SFO","ATL","SFO"]
Explanation: Another possible reconstruction is ["JFK","SFO","ATL","JFK","ATL","SFO"] but it is larger in lexical order.
 
Constraints:
1 <= tickets.length <= 300
tickets[i].length == 2
fromi.length == 3
toi.length == 3
fromi and toi consist of uppercase English letters.
fromi != toi



6. Pacific Atlantic Water Flow
There is an m x n rectangular island that borders both the Pacific Ocean and Atlantic Ocean. The Pacific Ocean touches the island's left and top edges, and the Atlantic Ocean touches the island's right and bottom edges.
The island is partitioned into a grid of square cells. You are given an m x n integer matrix heights where heights[r][c] represents the height above sea level of the cell at coordinate (r, c).
The island receives a lot of rain, and the rain water can flow to neighboring cells directly north, south, east, and west if the neighboring cell's height is less than or equal to the current cell's height. Water can flow from any cell adjacent to an ocean into the ocean.
Return a 2D list of grid coordinates result where result[i] = [ri, ci] denotes that rain water can flow from cell (ri, ci) to both the Pacific and Atlantic oceans.

Example 1:
Input: heights = [[1,2,2,3,5],[3,2,3,4,4],[2,4,5,3,1],[6,7,1,4,5],[5,1,1,2,4]]
Output: [[0,4],[1,3],[1,4],[2,2],[3,0],[3,1],[4,0]]
Explanation: The following cells can flow to the Pacific and Atlantic oceans, as shown below:
[0,4]: [0,4] -> Pacific Ocean 
       [0,4] -> Atlantic Ocean
[1,3]: [1,3] -> [0,3] -> Pacific Ocean 
       [1,3] -> [1,4] -> Atlantic Ocean
[1,4]: [1,4] -> [1,3] -> [0,3] -> Pacific Ocean 
       [1,4] -> Atlantic Ocean
[2,2]: [2,2] -> [1,2] -> [0,2] -> Pacific Ocean 
       [2,2] -> [2,3] -> [2,4] -> Atlantic Ocean
[3,0]: [3,0] -> Pacific Ocean 
       [3,0] -> [4,0] -> Atlantic Ocean
[3,1]: [3,1] -> [3,0] -> Pacific Ocean 
       [3,1] -> [4,1] -> Atlantic Ocean
[4,0]: [4,0] -> Pacific Ocean 
       [4,0] -> Atlantic Ocean
Note that there are other possible paths for these cells to flow to the Pacific and Atlantic oceans.

Example 2:
Input: heights = [[1]]
Output: [[0,0]]
Explanation: The water can flow from the only cell to the Pacific and Atlantic oceans.


Day 14: LLD
Loan FRS